\chapter{Overview of Performance Profilers }

In this chapter we present various characteristics and mechanisms of performance profilers. We will overview some contemporarily used profilers targeting .NET platform.


\section{Profiling modes}
An application can be profiled in several ways that differ in the results' precision, profiling overhead. 

\subsection{Sampling profiling}
In this mode, the profiler stops periodically every profilee's thread and inspects method frames on its call stacks. The output snapshot is not an exact representation of the runtime conditions rather a statistical approximation, but the profiling overhead is very low and the profilee runs almost in full speed with minimum side effects, such as additional memory allocations, cache faults and context switches.

The profiling overhead does not depend on the number of method called by the profilee as in other modes. The introduced error of the results is equal to half of the sampling period.

The profiler cannot count the number of method calls and the method duration are computed purely based on gathered statistics. 

No source code or binary alternations in required, the runtime ability to stop execution to do a call stack snapshot or alternatively an interrupt instruction can by used.

\subsection{Tracing profiling}
This way of profiling relies on a runtime environment or some kind of hardware notification when a method is entered and left and leads to accurate results, providing exact count of method calls and their durations, however, with some added overhead. In addition, the overhead increases with the method calls count and slows down the profilee.

As with the sampling profiling, there are no changes to code or binaries required. The profiler has to only register callback methods for the entry/leave notifications with the runtime or the hardware profiling infrastructure.

\subsection{Instrumentation profiling}
The profilee code or binaries are modified by injection of arbitrary code or instructions in order to collect profiling data. This approach can have similar effects and results as the tracing profiling, but offers a lot more choice of what and how to profile. There are chances of alternation the original profilee behaviour or even introducing bugs.

Instrumentation can be perform on every level of the software live-time (source, compilation, binary, runtime) and can be both manual, performed by a developer, as well as automatic, done by a compiler or a runtime environment.

\section{Granularity of profiling}
A profiler can measure profiling result on different levels of a program. Not every profiling approach can achieve any granularity due to its limitations. Speed of the profilee is always trade-off between granularity and accuracy. 

\subsection{Line-by-line granularity}
Line-by-line profiling is the most accurate method and most demanding. Every program statement is measured and analysed. It brings precise result, however, the additional burden can alter the program's behaviour.

Such fine granularity can be achieved only by the instrumentation profiling.

\subsection{Method granularity} 
Only information regarding an entire method run are collected. The lower overhead can ease the profilee and still provide very informative results.

This level of granularity is the only option for the sampling profilers and most cases the tracing profilers. The instrumentation profilers can be easily converted from the line-by-line to the method granularity.

\subsection{Selective granularity}
The profiling process can be filtered with combined levels of granularity, where some parts of code are monitored on the line-by-line and others only on the method manners or not at all in order to capture desired statistic with lowest possible overhead and highest possible accuracy.

\begin{figure}
	\centering
		\includegraphics[scale=.7]{\imagePath 01profilingModesComparisonTable.png}
		\caption{Profiling modes comparison}
	\label{fig:01profilingModesComparisonTable}
\end{figure}


\section{Profiling results}
During the process of profiling various kinds of data can be collected. For some application, it is sufficient to count the method hit count for others is a detailed call stack analysis required. Again, the amount of result information places overhead on the profilee, in this case primary on the memory (caches, pages...) and secondary on the CPU.

\subsection{Time measurement}
There are several different kinds of the program time measurement a profiler can provide. Not every profiling mode can provide every single measurement. As usually, the measurement accuracy is counterweighted with the computational complexity.

\subsubsection*{Wall time}
The wall time measurement starts when a thread enters a method and ends when the thread leaves the method. The resulting ti	me does not reflect if the method does useful computation or is in either a wait, a sleep or a join mode.

\subsubsection*{User and kernel time}
In comparison with the wall time, the user and kernel time measurement counts solely time spent executing a method exclusive the time spent by waiting, sleeping or joining.

Every profiling mode is capable of both the wall time as well as the user and kernel time measurement, either by statistically distributing the program execution time over the method hit counts or by reading CPU registers or system performance counters.

\subsection{Call trees}
When relations among methods calls allows the profiler to reconstruct a call tree. The call tree reveals hit count of functions and, more importantly, what function calls which function. This insight helps to find hot spots and understand the runtime conditions.
Additional function parameter analysis is also possible, but in cost of higher CPU and memory overhead. A example of a call tree is shown on the figure \ref{fig:01callGraphRedGate}.

\begin{figure}
	\centering
		\includegraphics[scale=.7]{\imagePath 01callGraphRedGate.png}
		\caption{Red-Gate ANTS Profiler call graph}
	\label{fig:01callGraphRedGate}
\end{figure}

Some profilers do not track calls hierarchy and they only record function hit count and duration. It is refered by the term flat call tree.

\section{Available .NET performance profilers}
On the market, there is many various options in the field of .NET performance profiling. The commertial solotions offer many features and integration with others tools, however, not with Visual Studio in most cases. There are also a few open source alternatives.

Unfortunately, we could not carry out deeper performance and feateru assemment of available profilers, since we do not have required financial and time resources for this challaging and but very interesting undertaking.

\subsection*{Commertial solutions}

\subsection{JetBrains dotTrace}
dotTrace profiles .NET Framework 1.0 to 4.0, Silverlight 4, or .NET Compact Framework 3.5. It offers partial integration with the Visual Studio and others JetBrains tools. All the profiling modes as presented and the profiling can run remotely.

\href{http://www.jetbrains.org}{www.jetbrains.org}

\subsection{Redgate ANTS Performance Profiler}
This tool targets similar set of .NET applications. In addition it offers Sql and I/O  profiling, live results, all the profiling modes and time schemas. 

It offers some integration in the Visual Studio and allows to see code directly from the profiling tool. 

\href{http://www.red-gate.com}{www.red-gate.com}

\subsection{EQATEC Profiler}
There is no doubt that this profiler offers the widest targeting platforms options. It can be used to profiler virtually anything in the ''.NET world''. It uses some kind of interumentation and thus the choise of the profiling mode is restricted, however it is configurable. A binary has to be modified before a profiling session.

There is no integration wiht the Visual Studio whatsowever and it seems that the source code result overview cannot be displayed either.

\href{http://www.eqatec.com}{www.eqatec.com}

\subsection{GlowCode}
GlowCode is a performance and memory profiler for Windows and .NET programmers who develop applications with C++ or any .NET Framework language. GlowCode helps to detect memory leaks and resource flaws, isolate performance bottlenecks, profile and tune code, trace real-time program execution, ensure code coverage, isolate boxing errors, identify excessive memory usage, and find hyperactive and loitering objects. For native, managed, and mixed code. \cite{Doeaaa} sfdfds \notice{Doeaaa}

